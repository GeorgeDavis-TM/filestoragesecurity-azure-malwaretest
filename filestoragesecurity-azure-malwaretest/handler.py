#!/usr/bin/env python3
import json
import zipfile
# import tarfile
# import gzip
import time
import rarfile
import os
import urllib3
import urllib.request
import urllib.parse
from bs4 import BeautifulSoup
import random
import datetime

import logging
import tempfile
import azure.functions as func
from azure.identity import DefaultAzureCredential
from azure.mgmt.storage import StorageManagementClient
from azure.storage.blob import BlobClient

# Create and configure logger
# logging.basicConfig(filename="newfile.log", format='%(asctime)s %(message)s', filemode='w')

logger = logging.getLogger()
logger.setLevel(logging.DEBUG)

def emptyDir(dir_path):

    # Empty /tmp folder for first time use
    for file_name in os.listdir(dir_path):

        os.remove(dir_path + "/" + file_name)

def zipDir(file_names, dir_path, temp_file):

    # Write a new zipfile without password
    with zipfile.ZipFile(temp_file, 'w') as zipFile:        

        for file_name in file_names:
            
            zipFile.write(dir_path + "/" + file_name)   

        zipFile.close()

    logger.info("Zip successful")

def deleteFileWithtemp_file(temp_file):

    logger.info("Deleting" +  str(temp_file) + "...")

    # Delete password protected zipfile    
    os.remove(temp_file)

def randomChoiceDict(srcDict):

    return random.choice(list(srcDict.items()))

def randomChoiceList(srcList):

    return random.choice(srcList)

def getfile(http):

    files_url = "http://www.tekdefense.com/downloads/malware-samples/"
    download_base_url = "http://www.tekdefense.com"

    r = http.request('GET', files_url)

    parsed_html = BeautifulSoup(r.data, 'html.parser')

    tempList = parsed_html.body.find_all('h3', attrs={'class': 'title'})

    linksDict = {}

    for link in tempList:

        linksDict.update({link.text: download_base_url + urllib.parse.quote(link.find('a').get("href"))})

    tempDict = {}

    for link in linksDict.keys():

        if ".exe.zip" not in link:

            tempDict.update({link: linksDict[link]})
    
    return randomChoiceDict(tempDict)

def zipRepack(zip_password, dir_path, file_name, temp_file):
    
    with zipfile.ZipFile(temp_file) as zipFile:

        zipFile.extractall(pwd=bytes(zip_password, 'utf-8'), path=dir_path)       

    deleteFileWithtemp_file(temp_file=temp_file)

    # file_names = os.listdir(dir_path)
    # logger.info("Directory - " + str(file_names))
    
    # # if file_name in file_names:
    # #     file_names.remove(file_name)        
    
    # zipDir(file_names, dir_path, temp_file)

# def tarRepack(dir_path, file_name):
        
#     tar = tarfile.open(dir_path + "/" + file_name)
#     names = tar.getnames()
#     temp_temp_file = ''
#     if os.path.isdir(dir_path + "/" + file_name + "_files"):
#         logger.info('file already exist')
#         temp_temp_file = os.path.isdir(dir_path + "/" + file_name + "_files")
#     else:
#         temp_temp_file = os.mkdir(dir_path + "/" + file_name + "_files")
#         logger.info('Create a new file_name')
#     # Because there are many files after decompression, a directory with the same name should be established in advance
#     for name in names:
#         tar.extract(name, dir_path + "/" + file_name + "_files/")
#     tar.close()
#     return temp_temp_file
    
# def gzipRepack(file_name):

#     f_name = file_name.replace(".gz", "")

#     # Get the name of the file, remove
#     g_file = gzip.GzipFile(file_name)

#     # Create gzip object
#     f = open(f_name, "w+").write(g_file.read())

#     # After the gzip object is opened with read(), it is written into the file created by open().
#     g_file.close()

def rarRepack(zip_password, dir_path, file_name, temp_file):
    
    with rarfile.Rarfile(dir_path + "/" + file_name) as file:
        file.extractall(pwd=zip_password)
        file.close()

    deleteFileWithtemp_file(temp_file=temp_file)

    # file_names = os.listdir(dir_path)
    # zipDir(file_names, dir_path, temp_file)

def repackWithoutPassword(file_extension, zip_password, dir_path, file_name, temp_file):
    
    if "zip" in file_extension:

        zipRepack(zip_password, dir_path, file_name, temp_file)

    elif "tar" in file_extension:

        rarRepack(zip_password, dir_path, file_name, temp_file)

    elif "gz" in file_extension:

        rarRepack(zip_password, dir_path, file_name, temp_file)

    elif "rar" in file_extension:
        
        rarRepack(zip_password, dir_path, file_name, temp_file)

    else:

        raise Exception("Unrecognized file extension: The file is not a zip, tar, tar.gz, rar.")

def getStorageAccountConnString(credential, subscription_id, resource_group_name, storage_account):

    storageClient = StorageManagementClient(credential, subscription_id)

    keys = storageClient.storage_accounts.list_keys(resource_group_name, storage_account)

    logger.info("Primary key for storage account: " + str(keys.keys[0].value))

    conn_string = "DefaultEndpointsProtocol=https;EndpointSuffix=core.windows.net;AccountName=" + storage_account + ";AccountKey=" + keys.keys[0].value

    logger.info("Connection string: " + str(conn_string))

def getResourceGroupName(credential, subscription_id, storage_account):

    storageClient = StorageManagementClient(credential, subscription_id)

    storage_accounts = storageClient.storage_accounts.list()

    for storage_account_item in storage_accounts:

        logger.info(str(storage_account_item))

        # if storage_account_item == storage_account:

        #     logger.info(str(storage_account_item))

def wait_for_copy(blob):
    count = 0
    props = blob.get_blob_properties()
    while props.copy.status == 'pending':
        count = count + 1
        if count > 10:
            raise TimeoutError('Timed out waiting for async copy to complete.')
        time.sleep(5)
        props = blob.get_blob_properties()
    return props

def blobStorageWriteToFile(storage_account, dir_path, file_name):
    
    credential = DefaultAzureCredential()
    subscription_id = str(os.environ.get("subscription_id"))
    resource_group_name = str(os.environ.get("resource_group"))

    storage_resource_group_name = getResourceGroupName(credential, subscription_id, storage_account)

    # getStorageAccountConnString(credential, subscription_id, storage_resource_group_name, storage_account)
    
    # Retrieve the storage blob service URL, which is of the form - https://<storage-account-name>.blob.core.windows.net/
    storage_url = "https://" + storage_account + ".blob.core.windows.net/"

    # Create the client object using the storage URL and the credential
    blob_client = BlobClient(account_url=storage_url, container_name=dir_path, blob_name=file_name, credential=credential)

    # Open a local file and upload its contents to Blob Storage
    blobUploadBlobResponse = None
    with open(file_name, "rb") as data:
        blobUploadBlobResponse = blob_client.upload_blob(data=data, overwrite=True)

    logger.info("\nblobUploadBlobResponse - " + str(blobUploadBlobResponse))
    
    wait_for_copy(blobUploadBlobResponse)

    return blobUploadBlobResponse

def antimalwaretest(azure_location_name, storage_account_name):

    logger.info("Azure Location - " + str(azure_location_name))

    user_agent = {'user-agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.2 Safari/605.1.15'}
    http = urllib3.PoolManager(5, headers=user_agent)

    file = getfile(http)

    file_name = file[0]
    file_url = file[1]

    zip_password = 'infected'

    # Attempt to download the various eicar test files
    logger.info("---Running Anti-Malware Test---")
    logger.info("Downloading Malware - " + str(file_url))

    # Building a new temp_file
    dir_path = tempfile.gettempdir()

    # dir_path = "/tmp/"
    # temp_file = dir_path + "/" + file_name

    # Empty /tmp folder for first time use
    emptyDir(dir_path)

    # Download file to custom temp_file
    with tempfile.NamedTemporaryFile(delete=False) as temp_file:
        r = http.request('GET', file_url)
        temp_file.file.write(r.data)

    logger.info(str(os.listdir()))

    file_extension = file_name.split(".")[-1].lower()

    repackWithoutPassword(file_extension, zip_password, dir_path, file_name, temp_file)    

    for file_name in os.listdir(dir_path):

        blobStorageWriteToFile(storage_account_name, dir_path, file_name)

    logger.info("Removing all Malware Files from Azure Function")
    
    emptyDir(dir_path)

def main(deployFssTimer: func.TimerRequest) -> None:

    try:

        utc_timestamp = datetime.datetime.now(datetime.timezone.utc).isoformat()

        if deployFssTimer.past_due:
            logger.info('The timer is past due!')

        logger.info('Python timer trigger function ran at ' + str(utc_timestamp))

        azure_location_name = os.environ.get("azure_location")
        storage_accounts = os.environ.get("storage_accounts")

        if storage_accounts[-1] == ",":
            storage_accounts = storage_accounts[:-1].replace(" ", "").split(",")
        else:
            storage_accounts = storage_accounts.replace(" ", "").split(",")

        storage_account_name = str(randomChoiceList(storage_accounts))
        logger.info("Target Azure Blob Storage Account: " + str(storage_account_name))

        antimalwaretest(azure_location_name, storage_account_name)

        body = {
            "message": "Go FSS-MalwareTest! Your function executed successfully!"        
        } # "input": event 

        return {"statusCode": 200, "body": json.dumps(body)}

    except Exception as e:
        logging.error("Err: " + str(e))
        raise Exception("Err: " + str(e))